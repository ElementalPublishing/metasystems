import subprocess
import sys
import os
import re

def run(cmd, cwd=None, check=True):
    print(f"$ {cmd}")
    result = subprocess.run(cmd, shell=True, cwd=cwd, capture_output=True, text=True)
    if result.stdout:
        print(result.stdout)
    if result.stderr:
        print(result.stderr)
    if check and result.returncode != 0:
        raise subprocess.CalledProcessError(result.returncode, cmd, output=result.stdout, stderr=result.stderr)
    return result

def check_uncommitted(project_dir):
    result = subprocess.run("git status --porcelain", shell=True, cwd=project_dir, capture_output=True, text=True)
    return result.stdout.strip()

def regenerate_cython(project_dir):
    print("Regenerating all .c files from .pyx Cython sources...")
    for root, dirs, files in os.walk(project_dir):
        for file in files:
            if file.endswith(".pyx"):
                pyx_path = os.path.join(root, file)
                print(f"Regenerating C file for {pyx_path}")
                run(f"cython {pyx_path}", cwd=project_dir)

def commit_all(msg, project_dir):
    run("git add .", cwd=project_dir, check=True)
    result = subprocess.run(
        f'git commit -m "{msg}"',
        shell=True,
        cwd=project_dir,
        capture_output=True,
        text=True
    )
    output = (result.stdout or "") + (result.stderr or "")
    if result.returncode == 0:
        print(result.stdout)
        return True
    elif "nothing to commit" in output or "nothing added to commit" in output:
        print("Nothing to commit.")
        return False
    else:
        print(result.stdout)
        print(result.stderr)
        raise subprocess.CalledProcessError(result.returncode, f'git commit -m "{msg}"', output=result.stdout, stderr=result.stderr)

def get_current_commit_hash(project_dir):
    result = subprocess.run("git rev-parse HEAD", shell=True, cwd=project_dir, capture_output=True, text=True)
    return result.stdout.strip()

def get_tags_for_commit(project_dir, commit_hash):
    result = subprocess.run(f"git tag --points-at {commit_hash}", shell=True, cwd=project_dir, capture_output=True, text=True)
    tags = result.stdout.strip().splitlines()
    return tags

def delete_tag(tag, project_dir):
    print(f"Deleting existing tag: {tag}")
    run(f"git tag -d {tag}", cwd=project_dir)
    run(f"git push origin :refs/tags/{tag}", cwd=project_dir)

def ensure_tagged_commit(project_dir):
    commit_hash = get_current_commit_hash(project_dir)
    tags = get_tags_for_commit(project_dir, commit_hash)
    if tags:
        print(f"Current commit is already tagged: {', '.join(tags)}")
        if len(tags) == 1:
            use_existing = input(f"Use existing tag '{tags[0]}' for build? (y/n): ").strip().lower()
            if use_existing == "y":
                return tags[0]
        # Remove all tags if not using existing
        for tag in tags:
            delete_tag(tag, project_dir)
    print("\nPyPI only accepts builds from tagged commits (no .dev0+... allowed).")
    tag = input("Enter a new version tag for this commit (e.g., v2.1.4): ").strip()
    if not tag:
        print("No tag entered. Exiting.")
        sys.exit(1)
    update_setup_py_version(project_dir, tag)
    run(f"git add setup.py", cwd=project_dir)
    run(f'git commit -m "Update setup.py version to {tag.lstrip("v")}"', cwd=project_dir)
    run(f"git tag {tag}", cwd=project_dir)
    run(f"git push origin {tag}", cwd=project_dir)
    print(f"Tagged current commit as {tag}.")
    return tag

def build(project_dir):
    print("Building sdist and wheel from the tagged commit...")
    run("python -m build --sdist --wheel --no-isolation", cwd=project_dir)

def delete_c_files(project_dir):
    print("Deleting all .c files generated by Cython...")
    for root, dirs, files in os.walk(project_dir):
        for file in files:
            if file.endswith(".c"):
                c_path = os.path.join(root, file)
                print(f"Deleting {c_path}")
                try:
                    os.remove(c_path)
                except Exception as e:
                    print(f"Could not delete {c_path}: {e}")

def update_setup_py_version(project_dir, tag):
    setup_path = os.path.join(project_dir, "setup.py")
    if not os.path.exists(setup_path):
        print("No setup.py found, skipping version update.")
        return
    # Remove leading 'v' if present
    version = tag.lstrip("v")
    with open(setup_path, "r", encoding="utf-8") as f:
        content = f.read()
    # Replace the version line
    new_content, n = re.subn(
        r'version\s*=\s*["\'].*?["\']',
        f'version="{version}"',
        content,
        count=1
    )
    if n == 0:
        print("No version field found in setup.py to update.")
        return
    with open(setup_path, "w", encoding="utf-8") as f:
        f.write(new_content)
    print(f"Updated setup.py to version {version}")

def main():
    project_dir = input("Enter project folder (leave blank for current): ").strip() or os.getcwd()
    uncommitted = check_uncommitted(project_dir)
    if uncommitted:
        print("Uncommitted changes detected:\n")
        print(uncommitted)
        auto_commit = input("Would you like to automatically stage and commit all changes? (y/n): ").strip().lower()
        if auto_commit == "y":
            msg = input("Enter commit message (leave blank for default): ").strip() or "Automated commit by gitdestroyer"
            commit_all(msg, project_dir)
        else:
            print("Please commit or stash your changes and rerun the script.")
            sys.exit(1)
    regenerate_cython(project_dir)
    committed = commit_all("Automated release commit by gitdestroyer", project_dir)
    if not committed:
        print("No new commits. You may want to clean build artifacts or continue.")
    tag = ensure_tagged_commit(project_dir)
    update_setup_py_version(project_dir, tag)
    build(project_dir)
    delete_c_files(project_dir)
    print(f"\nAll done! Built from tag {tag}. Your dist/ folder is ready for PyPI upload.")

if __name__ == "__main__":
    main()